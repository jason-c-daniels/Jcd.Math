<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jcd.Math</name>
    </assembly>
    <members>
        <member name="T:Jcd.Math.Compare">
            <summary>
            1. A set of upcoming C# features:
               Generic `Min`, `Max`, and `Clamp`. Once MS has implemented these
               (C# 11, .NET7?) they will be off of the Math. class.
            
            2. Some custom extension methods that everyone seems to have to
               create, despite well known algorithms. (InRange and CompareToRange)
             
            </summary>
        </member>
        <member name="M:Jcd.Math.Compare.Min``1(``0,``0)">
            <summary>
            Returns the lesser of two values for an IComparable&lt;T&gt;
            </summary>
            <param name="val1">The first of two values to compare.</param>
            <param name="val2">The second of two values to compare.</param>
            <typeparam name="T">The data type of the values.</typeparam>
            <returns>The smaller of the two values. `val1` if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Compare.Min``1(``0,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the lesser of two values for an IComparable&lt;T&gt;
            </summary>
            <param name="val1">The first of two values to compare.</param>
            <param name="val2">The second of two values to compare.</param>
            <param name="comparer">A value comparer to use for the comparisons.</param>
            <typeparam name="T">The data type of the values.</typeparam>
            <returns>The smaller of the two values. `val1` if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Compare.Max``1(``0,``0)">
            <summary>
            Returns the greater of two values for an IComparable&lt;T&gt;
            </summary>
            <param name="val1">The first value to compare.</param>
            <param name="val2">The second value to compare.</param>
            <typeparam name="T">The data type of the values.</typeparam>
            <returns>The greater of the two values. `val1` if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Compare.Max``1(``0,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the greater of two values for an IComparable&lt;T&gt;
            </summary>
            <param name="val1">The first of two values to compare.</param>
            <param name="val2">The second of two values to compare.</param>
            <param name="comparer">A value comparer to use for the comparisons.</param>
            <typeparam name="T">The data type of the values.</typeparam>
            <returns>The greater of the two values. `val1` if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Compare.Clamp``1(``0,``0,``0)">
            <summary>
            Returns a `value` clamped to the inclusive range of `min` and `max`.
            </summary>
            <param name="value">The value to be clamped.</param>
            <param name="min">The lower bounds of the result.</param>
            <param name="max">The upper bounds of the result.</param>
            <typeparam name="T">The data type.</typeparam>
            <returns>
                - `min` : when `value` &lt; `min`.
            -or-
                - `max` : when `value` &gt; `max`.
            -or-
                - `value` : when `min` ≤ `value` ≤ `max`.
            </returns>
        </member>
        <member name="M:Jcd.Math.Compare.Clamp``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Clamps a value to the specified range.
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value for the range.</param>
            <param name="max">The maximum value for the range.</param>
            <param name="comparer">The value comparer</param>
            <typeparam name="T">The data type.</typeparam>
            <returns>
                - min if value less than min,
                - max if value greater than max,
                - value otherwise.
            </returns>
        </member>
        <member name="M:Jcd.Math.Compare.InRange``1(``0,``0,``0)">
            <summary>
            Checks if a value is within a closed interval. (i.e. interval includes start and endpoints)
            </summary>
            <param name="value">The value to compare</param>
            <param name="start">Start of the range to check</param>
            <param name="end">End of the range to check.</param>
            <typeparam name="T">The data type being compared.</typeparam>
            <returns>true if the value is within the range.</returns>
        </member>
        <member name="M:Jcd.Math.Compare.ToRange``1(``0,``0,``0)">
            <summary>
            Determines if a value is less than the start (-1) of the
            closed interval [start,end], within the interval (0),
            or after the end of the interval (1)
            </summary>
            <param name="value">The value to compare</param>
            <param name="start">Start of the range to check</param>
            <param name="end">End of the range to check.</param>
            <typeparam name="T">The data type being compared.</typeparam>
            <returns>-1, for less than, 0 for in range, 1 for greater than end.</returns>
        </member>
        <member name="T:Jcd.Math.IDisjointComparer`2">
            <summary>
            A generic IComparer interface implements a method that compares 
            two objects of differing types. It is used in conjunction with
            the Infinity and Number structs to provide comparisons.
            </summary>
            <typeparam name="T1">The first type.</typeparam>
            <typeparam name="T2">The second type.</typeparam>
        </member>
        <member name="M:Jcd.Math.IDisjointComparer`2.Compare(`0,`1)">
            <summary>
            Compares an instance of T1 to an instance of T2.
            </summary>
            <param name="x">The first item to compare</param>
            <param name="y">The second item to compare</param>
            <returns>
            *  0 when x == y
            * -1 when x lt; y
            *  1 when x gt; y
            </returns>
        </member>
        <member name="M:Jcd.Math.IDisjointComparer`2.Compare(`1,`0)">
            <summary>
            Compares an instance of T1 to an instance of T2.
            </summary>
            <param name="x">The first item to compare</param>
            <param name="y">The second item to compare</param>
            <returns>
            *  0 when x == y
            * -1 when x lt; y
            *  1 when x gt; y
            </returns>
        </member>
        <member name="T:Jcd.Math.IDisjointEqualityComparer`2">
            <summary>
            Defines methods to support the comparison of two items of differing
            types for equality.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="M:Jcd.Math.IDisjointEqualityComparer`2.Equals(`0,`1)">
            <summary>
            Compares an instance of T1 to an instance of T2.
            </summary>
            <param name="x">The first item to compare</param>
            <param name="y">The second item to compare</param>
            <returns>True if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.IDisjointEqualityComparer`2.Equals(`1,`0)">
            <summary>
            Compares an instance of T1 to an instance of T2.
            </summary>
            <param name="x">The first item to compare</param>
            <param name="y">The second item to compare</param>
            <returns>True if equivalent.</returns>
        </member>
        <member name="T:Jcd.Math.Intervals.IInterval`1">
            <summary>
            Defines the operations and properties needed to create an interval.
            </summary>
            <typeparam name="T">The underlying data type for the interval.</typeparam>
        </member>
        <member name="P:Jcd.Math.Intervals.IInterval`1.IsValid">
            <summary>
            Indicates if the interval was properly constructed.
            </summary>
            <remarks>
            The only way for this to be false is by using an
            uninitialized instance. Sadly, structs zero out all
            fields and properties in an uninitialized instance.
            (This is a .Net standard 2.0 assembly after all)
            </remarks> 
        </member>
        <member name="P:Jcd.Math.Intervals.IInterval`1.IsEmpty">
            <summary>
             Indicates if the interval is empty:
            (0,0), (1,1) ...etc. are empty intervals.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IInterval`1.IsSingleValue">
            <summary>
            Indicates if the interval is empty:
            [0,0], [1,1] ...etc. are single value intervals.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IInterval`1.Start">
            <summary>
            The start of the interval.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IInterval`1.End">
            <summary>
            The end of the interval.
            </summary>
        </member>
        <member name="M:Jcd.Math.Intervals.IInterval`1.Contains(`0)">
            <summary>
            Determines if the interval contains the provided point.
            </summary>
            <param name="value">The point to compare</param>
            <returns>True if the interval contains the point.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IInterval`1.Contains(Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if the interval contains the provided limit.
            </summary>
            <param name="limit">The limit to inspect.</param>
            <returns>True if the interval contains the limit.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IInterval`1.Contains(Jcd.Math.Intervals.IInterval{`0})">
            <summary>
            Determines if this interval completely contains another.
            </summary>
            <param name="other">The interval being compared for containment within the current.</param>
            <returns>True if this interval contains the other.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IInterval`1.IntersectsWith(Jcd.Math.Intervals.IInterval{`0})">
            <summary>
            Determines if the current interval contains any values
            in common with another interval.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Jcd.Math.Intervals.Interval`1">
            <summary>
            Represents a mathematical interval whose limits can be any 
            pairing of Unbounded, Closed or Open.
            </summary>
            <typeparam name="T">The underlying data type for the interval.</typeparam>
        </member>
        <member name="P:Jcd.Math.Intervals.Interval`1.IsValid">
            <summary>
            Indicates if the interval was properly constructed.
            </summary>
            <remarks>
            The only way for this to be false is by using an
            uninitialized instance. Sadly, structs zero out all
            fields and properties in an uninitialized instance.
            (This is a .Net standard 2.0 assembly after all)
            </remarks> 
        </member>
        <member name="P:Jcd.Math.Intervals.Interval`1.ContainsAll">
            <summary>
            Indicates if this interval is the interval of all numbers.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.Interval`1.IsEmpty">
            <summary>
             Indicates if the interval is empty:
            (0,0), (1,1) ...etc. are empty intervals.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.Interval`1.IsSingleValue">
            <summary>
            Indicates if the interval is empty:
            [0,0], [1,1] ...etc. are single value intervals.
            </summary>
        </member>
        <member name="F:Jcd.Math.Intervals.Interval`1.Empty">
            <summary>
            The empty interval
            </summary>
        </member>
        <member name="F:Jcd.Math.Intervals.Interval`1.All">
            <summary>
            The interval containing all values.
            </summary>
        </member>
        <member name="F:Jcd.Math.Intervals.Interval`1.Invalid">
            <summary>
            By default an uninitialized and invalid instance.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.Interval`1.Start">
            <summary>
            The start of the interval.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.Interval`1.End">
            <summary>
            The end of the interval.
            </summary>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Create(Jcd.Math.Intervals.IntervalLimit{`0},Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Creates an interval from two limits.
            </summary>
            <remarks>
            Any limit type can be passed in. Their types are converted
            and all other attributes are preserved.
            </remarks>
            <param name="start">The starting limit for the interval</param>
            <param name="end">The end limit for the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Closed(`0,`0)">
            <summary>
            Creates an closed interval: [closedStart,closedEnd]
            (i.e. includes both closedStart and closedEnd)
            </summary>
            <param name="closedStart">The inclusive starting point of the interval</param>
            <param name="closedEnd">The inclusive openEnd point of the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Open(`0,`0)">
            <summary>
            Creates an open interval: (openStart,openEnd)
            (i.e. excludes both openStart and openEnd)
            </summary>
            <param name="openStart">The exclusive starting point of the interval</param>
            <param name="openEnd">The exclusive openEnd point of the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.OpenClosed(`0,`0)">
            <summary>
            Creates an open-closed interval: (openStart,closedEnd]
            (i.e. excludes openStart and includes closedEnd)
            </summary>
            <param name="openStart">The exclusive starting point of the interval</param>
            <param name="closedEnd">The inclusive openEnd point of the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.ClosedOpen(`0,`0)">
            <summary>
            Creates a closed-open interval: [openStart,closedEnd)
            (i.e. includes openStart and excludes closedEnd)
            </summary>
            <param name="closedStart">The inclusive starting point of the interval</param>
            <param name="openEnd">The exclusive openEnd point of the interval.</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.UnboundedOpen(`0)">
            <summary>
            Creates a left-unbounded, right-open interval: (-infinity, openEnd)
            (i.e. -infinity to openEnd - excludes openEnd.)
            </summary>
            <param name="openEnd">The exclusive end point of the interval.</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.UnboundedClosed(`0)">
            <summary>
            Creates a left-unbounded, right-closed interval: (-infinity, closedEnd]
            (i.e. -infinity to closedEnd - includes closedEnd.)
            </summary>
            <param name="closedEnd">The inclusive end point of the interval.</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.ClosedUnbounded(`0)">
            <summary>
            Creates a left-closed, right-unbounded interval: [closedStart, +infinity)
            (i.e. openStart to +infinity - includes openStart.)
            </summary>
            <param name="closedStart">The inclusive openStart point of the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.OpenUnbounded(`0)">
            <summary>
            Creates a left-open, right-unbounded interval: (openStart, +infinity)
            (i.e. openStart to +infinity - excludes openStart.)
            </summary>
            <param name="openStart">the exclusive start to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Unbounded">
            <summary>
            Creates a completely unbounded interval. (-infinity, +infinity)
            (i.e. -infinity to +infinity - excluding the infinities, of course.)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Contains(`0)">
            <summary>
            Determines if the interval contains the provided value.
            </summary>
            <param name="value">The value to check for inclusion in the interval.</param>
            <returns>True if the interval contains the value.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Contains(Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if the interval contains the value represented by limit.
            (e.g. A left-unbounded interval will contain any discrete value less
            than or equal to the end of the interval.)
            </summary>
            <param name="limit">The limit to inspect.</param>
            <returns>True if the interval contains the limit.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Contains(Jcd.Math.Intervals.IInterval{`0})">
            <summary>
            Returns true if this interval completely contains the provided interval.
            </summary>
            <param name="other">The interval being compared for containment within the current.</param>
            <returns>True if this interval contains both endpoints of `other`.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.IntersectsWith(Jcd.Math.Intervals.IInterval{`0})">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Contains(Jcd.Math.Intervals.Interval{`0})">
            <summary>
            Determines if this interval completely contains another.
            </summary>
            <param name="other">The interval being compared for containment within the current.</param>
            <returns>True if this interval contains the other.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Equals(Jcd.Math.Intervals.IInterval{`0})">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Equals(Jcd.Math.Intervals.Interval{`0})">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.op_Equality(Jcd.Math.Intervals.Interval{`0},Jcd.Math.Intervals.Interval{`0})">
            <summary>
            Performs equivalence comparisons between two intervals.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if they're equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.op_Inequality(Jcd.Math.Intervals.Interval{`0},Jcd.Math.Intervals.Interval{`0})">
            <summary>
            Performs non-equivalence comparison between two intervals.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if they're not equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Math.Intervals.Interval">
            <summary>
            A helper class to simplify the notation for creating intervals.
            </summary>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.Create``1(Jcd.Math.Intervals.IntervalLimit{``0},Jcd.Math.Intervals.IntervalLimit{``0})">
            <summary>
            Creates an interval from two limits.
            </summary>
            <param name="start">The starting limit of the interval</param>
            <param name="end">The end limit of the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.Closed``1(``0,``0)">
            <summary>
            Creates an closed interval: [closedStart,closedEnd]
            (i.e. includes both closedStart and closedEnd)
            </summary>
            <param name="closedStart">the inclusive start to the interval</param>
            <param name="closedEnd">The inclusive end to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.Open``1(``0,``0)">
            <summary>
            Creates an open interval: (openStart,openEnd)
            (i.e. excludes both openStart and openEnd)
            </summary>
            <param name="openStart">The exclusive start to the interval.</param>
            <param name="openEnd">The exclusive end to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.OpenClosed``1(``0,``0)">
            <summary>
            Creates an open-closed interval: (openStart,closedEnd]
            (i.e. excludes openStart and includes closedEnd)
            </summary>
            <param name="openStart">The exclusive start to the interval.</param>
            <param name="closedEnd">The inclusive end to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.ClosedOpen``1(``0,``0)">
            <summary>
            Creates a closed-open interval: [closedStart,openEnd)
            (i.e. includes closedStart and excludes openEnd)
            </summary>
            <param name="closedStart">the inclusive start to the interval</param>
            <param name="openEnd">The exclusive end to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.UnboundedOpen``1(``0)">
            <summary>
            Creates a left-unbounded, right-open interval: (-infinity, openEnd)
            (i.e. -infinity to openEnd - excludes openEnd.)
            </summary>
            <param name="openEnd">The exclusive end to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.UnboundedClosed``1(``0)">
            <summary>
            Creates a left-unbounded, right-closed interval: (-infinity, closedEnd]
            (i.e. -infinity to closedEnd - includes closedEnd.)
            </summary>
            <param name="closedEnd">The inclusive end to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.ClosedUnbounded``1(``0)">
            <summary>
            Creates a left-closed, right-unbounded interval: [closedStart, +infinity)
            (i.e. closedStart to +infinity - includes closedStart.)
            </summary>
            <param name="closedStart">the inclusive start to the interval</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.OpenUnbounded``1(``0)">
            <summary>
            Creates a left-open, right-unbounded interval: (openStart, +infinity)
            (i.e. openStart to +infinity - excludes openStart.)
            </summary>
            <param name="openStart">The exclusive start to the interval.</param>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.Unbounded``1">
            <summary>
            Creates a completely unbounded interval. (-infinity, +infinity)
            (i.e. -infinity to +infinity - excluding the infinities, of course.)
            </summary>
            <returns>The new interval</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.Interval.Intersect``1(Jcd.Math.Intervals.Interval{``0},Jcd.Math.Intervals.Interval{``0})">
            <summary>
            Creates the intersection of two intervals.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Jcd.Math.Intervals.IntervalLimit`1">
            <summary>
            Defines a limit point in an interval. (i.e. starting point or ending point.) 
            </summary>
            <typeparam name="T">The data type for the interval using this limit.</typeparam>
            <remarks>
            For the purposes of this library:
              * An Unbounded interval limit is both open and infinite. (HasLimitValue == false &amp;&amp; IsUnbounded == true &amp;&amp; IsOpen == true).
              * An Open interval limit is a finite and open limit.  (i.e. HasLimitValue == true &amp;&amp; IsUnbounded == false &amp;&amp; IsOpen == true).
              * A Closed interval limit is both closed and finite. (i.e. HasLimitValue == true &amp;&amp; IsUnbounded == false &amp;&amp; IsOpen == false).
              * Start interval limits compare as less than or equal to End interval limits for the same non-infinite limit value, depending on the Closed-Open nature of the limits being compared.
              * Start interval limits compare as less than End interval limits for infinite (Unbounded) limit values.
              * Open-Start interval limits compare greater than Closed-Start interval limits.
              * Open-End interval limits compare less than Closed-End interval limits.
              * Unbounded-Start interval limits compare less than Open or Closed-Start interval limits.
              * Unbounded-End interval limits compare greater than Open or Closed-End interval limits.
            </remarks>
        </member>
        <member name="F:Jcd.Math.Intervals.IntervalLimit`1.Default">
            <summary>
            The default IntervalLimit. This is equivalent to IntervalLimit&lt;T&gt;.UnboundedStart
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.Constraint">
            <summary>
            Unbounded (i.e. no limit), Open, Closed. 
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.Limit">
            <summary>
            The limit value for the interval point, if applicable. (Unbounded = default(T), the value is ignored for comparisons.)
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.LimitType">
            <summary>
            The type of interval limit, Start or End. This dictates how comparisons happen.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.IsStart">
            <summary>
            Indicates if this interval limit is a start limit.
            When true and Unbounded is true the Limit value is treated as -infinity.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.IsEnd">
            <summary>
            Indicates if this interval limit is an interval end limit.
            When true and Unbounded is true the Limit value is treated as +infinity.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.IsOpen">
            <summary>
            Indicates if the limit is open. (Note: Unbounded is open at +/-infinity)
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.IsClosed">
            <summary>
            Indicates if the limit is closed.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.IsUnbounded">
            <summary>
            Indicates if the limit is unbounded.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimit`1.HasLimitValue">
            <summary>
            Indicates if there is a discrete, non-infinite value for the limit.
            </summary>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.#ctor(Jcd.Math.Intervals.IntervalLimitType,Jcd.Math.Intervals.IntervalLimitConstraint,`0)">
            <summary>
            Construct an interval limit from a limit value, constraint and type. 
            </summary>
            <param name="limitType">The interval limit type.</param>
            <param name="constraint">The limit constraints.</param>
            <param name="limit">The limit value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.UnboundedStart">
            <summary>
            Creates an unbounded start interval limit.
            In other words: creates an exclusive infinite start limit.  
            For example: (-infinity,... 
            </summary>
            <returns>The new interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.UnboundedEnd">
            <summary>
            Creates an unbounded end interval limit
            In other words: creates an exclusive infinite end limit.  
            For example: ...,+infinity) 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.OpenStart(`0)">
            <summary>
            Creates an open-start interval limit.
            In other words: creates an exclusive start limit.  
            For example: (limit,... 
            </summary>
            <param name="limit">the limiting value.</param>
            <returns>The new interval limit.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.ClosedStart(`0)">
            <summary>
            Creates a closed start interval limit.
            In other words: creates an inclusive start limit.  
            For example: [limit,... 
            </summary>
            <param name="limit">the limiting value.</param>
            <returns>The new interval limit.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.OpenEnd(`0)">
            <summary>
            Creates an open end interval limit.
            In other words: creates an exclusive end limit.  
            For example: ...,limit) 
            </summary>
            <param name="limit">the limiting value.</param>
            <returns>The new interval limit.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.ClosedEnd(`0)">
            <summary>
            Creates an open end interval limit.
            In other words: creates an inclusive end limit.  
            For example: ...,limit]
            </summary>
            <param name="limit">the limiting value.</param>
            <returns>The new interval limit.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.CompareTo(Jcd.Math.Intervals.IntervalLimit{`0})">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_LessThan(Jcd.Math.Intervals.IntervalLimit{`0},`0)">
            <summary>
            Determines if an interval limit is less than a specified value. 
            </summary>
            <param name="left">The interval limit to compare.</param>
            <param name="right">The value to compare</param>
            <returns>True if the interval limit is less than the specified value.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_GreaterThan(Jcd.Math.Intervals.IntervalLimit{`0},`0)">
            <summary>
            Determines if an interval limit is greater than a specified value. 
            </summary>
            <param name="left">The interval limit to compare.</param>
            <param name="right">The value to compare</param>
            <returns>True if the interval limit is greater than the specified value.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_LessThanOrEqual(Jcd.Math.Intervals.IntervalLimit{`0},`0)">
            <summary>
            Determines if an interval limit is less than or equal to a specified value. 
            </summary>
            <param name="left">The interval limit to compare.</param>
            <param name="right">The value to compare</param>
            <returns>True if the interval limit is less than or equal to the specified value.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_GreaterThanOrEqual(Jcd.Math.Intervals.IntervalLimit{`0},`0)">
            <summary>
            Determines if an interval limit is less greater or equal to a specified value. 
            </summary>
            <param name="left">The interval limit to compare.</param>
            <param name="right">The value to compare</param>
            <returns>True if the interval limit is greater than or equal to the specified value.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_LessThan(`0,Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if a specified value is less than an interval limit.
            </summary>
            <param name="left">the specified value.</param>
            <param name="right">The interval limit</param>
            <returns>True if the specified value is less than the interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_GreaterThan(`0,Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if a specified value is greater than an interval limit.
            </summary>
            <param name="left">the specified value.</param>
            <param name="right">The interval limit</param>
            <returns>True if the specified value is greater than the interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_LessThanOrEqual(`0,Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if a specified value is less than or equal to an interval limit.
            </summary>
            <param name="left">the specified value.</param>
            <param name="right">The interval limit</param>
            <returns>True if the specified value is less than or equal to the interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_GreaterThanOrEqual(`0,Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if a specified value is greater than or equal to an interval limit.
            </summary>
            <param name="left">the specified value.</param>
            <param name="right">The interval limit</param>
            <returns>True if the specified value is greater than or equal to the interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_LessThan(Jcd.Math.Intervals.IntervalLimit{`0},Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if one interval limit is less than another.
            </summary>
            <param name="left">the left hand parameter</param>
            <param name="right">the right hand parameter</param>
            <returns>True if left is less than right</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_GreaterThan(Jcd.Math.Intervals.IntervalLimit{`0},Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if one interval limit is greater than another.
            </summary>
            <param name="left">the left hand parameter</param>
            <param name="right">the right hand parameter</param>
            <returns>True if left is greater than right</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_LessThanOrEqual(Jcd.Math.Intervals.IntervalLimit{`0},Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if one interval limit is less than or equal to another.
            </summary>
            <param name="left">the left hand parameter</param>
            <param name="right">the right hand parameter</param>
            <returns>True if left is less than or equal to right</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_GreaterThanOrEqual(Jcd.Math.Intervals.IntervalLimit{`0},Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Determines if one interval limit is greater than or equal to another.
            </summary>
            <param name="left">the left hand parameter</param>
            <param name="right">the right hand parameter</param>
            <returns>True if left is greater than or equal to right</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.Equals(Jcd.Math.Intervals.IntervalLimit{`0})">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.CompareTo(`0)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.Equals(`0)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_Equality(Jcd.Math.Intervals.IntervalLimit{`0},Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Equivalence operator.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_Inequality(Jcd.Math.Intervals.IntervalLimit{`0},Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Non=equivalence operator.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if not equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_Equality(Jcd.Math.Intervals.IntervalLimit{`0},`0)">
            <summary>
            Equivalence operator.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_Inequality(Jcd.Math.Intervals.IntervalLimit{`0},`0)">
            <summary>
            Non=equivalence operator.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if not equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_Equality(`0,Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Equivalence operator.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_Inequality(`0,Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Non=equivalence operator.
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>True if not equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.op_Explicit(Jcd.Math.Intervals.IntervalLimit{`0})~`0">
            <summary>
            Converts to the underlying value type.
            </summary>
            <param name="limit">The limit to convert.</param>
            <returns>The underlying value.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.MakeStart(Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Ensures that an interval limit is a start limit by examining properties
            and, if necessary returning a new instance. Boundedness, Openness and
            Limit value are all retained.
            </summary>
            <param name="value">The value to convert.</param>
            <typeparam name="T">The underlying data type.</typeparam>
            <returns>A start limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit`1.MakeEnd(Jcd.Math.Intervals.IntervalLimit{`0})">
            <summary>
            Ensures that an interval limit is a end limit by examining properties
            and, if necessary returning a new instance. Boundedness, Openness and
            Limit value are all retained.
            </summary>
            <param name="value">The value to convert.</param>
            <typeparam name="T">The underlying data type.</typeparam>
            <returns>An end limit</returns>
        </member>
        <member name="T:Jcd.Math.Intervals.IntervalLimit">
            <summary>
            Helper class to simplify the notation when creating an interval limit.
            </summary>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit.UnboundedStart``1">
            <summary>
            Creates an unbounded start interval limit.
            In other words: creates an exclusive infinite start limit.  
            For example: (-infinity,... 
            </summary>
            <returns>The new interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit.UnboundedEnd``1">
            <summary>
            Creates an unbounded end interval limit.
            In other words: creates an exclusive infinite end limit.  
            For example: ...,+infinity) 
            </summary>
            <returns>The new interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit.OpenStart``1(``0)">
            <summary>
            Creates an open start interval limit.
            In other words: creates an exclusive start limit.  
            For example: (limit,... 
            </summary>
            <returns>The new interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit.ClosedStart``1(``0)">
            <summary>
            Creates a closed start interval limit.
            In other words: creates an inclusive start limit.  
            For example: [limit,... 
            </summary>
            <returns>The new interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit.OpenEnd``1(``0)">
            <summary>
            Creates an open end interval limit.
            In other words: creates an exclusive end limit.  
            For example: ...,limit) 
            </summary>
            <returns>The new interval limit</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimit.ClosedEnd``1(``0)">
            <summary>
            Creates a closed end interval limit.
            In other words: creates an inclusive end limit.  
            For example: ...,limit] 
            </summary>
            <returns>The new interval limit</returns>
        </member>
        <member name="T:Jcd.Math.Intervals.IntervalLimitConstraint">
            <summary>
            Describes how an endpoint in an interval is to be handled (Open with limit?
            Fully open? Closed on the limit?)
            </summary>
        </member>
        <member name="F:Jcd.Math.Intervals.IntervalLimitConstraint.Unbounded">
            <summary>
            The endpoint in question has no limit and therefore is fully open.
            </summary>
            <remarks>
            For a start point on a one dimensional scale this implies all values from -infinity
            to the end limit are part of the interval. (The end limit may be an open limit
            and therefore exclude the limit point making [-infinity,end) the appropriate
            representation for the interval.
            </remarks> 
        </member>
        <member name="F:Jcd.Math.Intervals.IntervalLimitConstraint.Open">
            <summary>
            The endpoint in question has a limit and is open. (i.e. excludes the limit point)
            </summary>
        </member>
        <member name="F:Jcd.Math.Intervals.IntervalLimitConstraint.Closed">
            <summary>
            The endpoint in question has a limit and is closed. (i.e. includes the limit point)
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimitConstraint.IsClosed">
            <summary>
            Indicates if the specified interval endpoint contains the
            point in question.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimitConstraint.IsOpen">
            <summary>
            Indicates if the specified interval endpoint includes the
            start/end point in question.
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimitConstraint.HasLimitValue">
            <summary>
            Indicates if the specified interval endpoint contains any
            limit whatsoever. (i.e. is it fully open at the start or end?)
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimitConstraint.IsUnbounded">
            <summary>
            Indicates if there is no limit on the bounds of this constraint.
            This is effectively -infinity or +infinity depending on context.
            </summary>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitConstraint.Equals(Jcd.Math.Intervals.IntervalLimitConstraint)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitConstraint.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitConstraint.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitConstraint.op_Equality(Jcd.Math.Intervals.IntervalLimitConstraint,Jcd.Math.Intervals.IntervalLimitConstraint)">
            <summary>
            Equivalence operator
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>true if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitConstraint.op_Inequality(Jcd.Math.Intervals.IntervalLimitConstraint,Jcd.Math.Intervals.IntervalLimitConstraint)">
            <summary>
            Non-equivalence operator
            </summary>
            <param name="left">The left hand parameter</param>
            <param name="right">The right hand parameter</param>
            <returns>true if not equivalent.</returns>
        </member>
        <member name="T:Jcd.Math.Intervals.IntervalLimitType">
            <summary>
            An equatable and comparable type-safe and highly performant DDD-like enumeration type.
            To keep high performance the usual DDD name/description property is omitted.
            </summary>
        </member>
        <member name="F:Jcd.Math.Intervals.IntervalLimitType.Start">
            <summary>
            The start point of an interval. Start must be &lt;= end
            </summary>
        </member>
        <member name="F:Jcd.Math.Intervals.IntervalLimitType.End">
            <summary>
            The end point of an interval. End must be &gt;= start
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimitType.IsStart">
            <summary>
            Indicates if this is a Start IntervalLimitType
            </summary>
        </member>
        <member name="P:Jcd.Math.Intervals.IntervalLimitType.IsEnd">
            <summary>
            Indicates if this is an End IntervalLimitType
            </summary>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.Equals(Jcd.Math.Intervals.IntervalLimitType)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_Equality(Jcd.Math.Intervals.IntervalLimitType,Jcd.Math.Intervals.IntervalLimitType)">
            <summary>
            Compares two IntervalLimitTypes for equality.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>True if they're equal.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_Inequality(Jcd.Math.Intervals.IntervalLimitType,Jcd.Math.Intervals.IntervalLimitType)">
            <summary>
            Compares two IntervalLimitTypes for inequality.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>True if they're not equal.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.CompareTo(Jcd.Math.Intervals.IntervalLimitType)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_LessThan(Jcd.Math.Intervals.IntervalLimitType,Jcd.Math.Intervals.IntervalLimitType)">
            <summary>
            Checks if the left hand IntervalLimitType is less than the right hand IntervalLimitType.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>True if left is less than right.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_GreaterThan(Jcd.Math.Intervals.IntervalLimitType,Jcd.Math.Intervals.IntervalLimitType)">
            <summary>
            Checks if the left hand IntervalLimitType is greater than the right hand IntervalLimitType.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>True if left is greater than right.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_LessThanOrEqual(Jcd.Math.Intervals.IntervalLimitType,Jcd.Math.Intervals.IntervalLimitType)">
            <summary>
            Checks if the left hand IntervalLimitType is less than or equal to the right hand IntervalLimitType.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>True if left is less than or equal to right.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_GreaterThanOrEqual(Jcd.Math.Intervals.IntervalLimitType,Jcd.Math.Intervals.IntervalLimitType)">
            <summary>
            Checks if the left hand IntervalLimitType is greater than or equal to the right hand IntervalLimitType.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>True if left is greater  than or equal to right.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_Explicit(System.Byte)~Jcd.Math.Intervals.IntervalLimitType">
            <summary>
            Conversion operator from byte.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.op_Explicit(Jcd.Math.Intervals.IntervalLimitType)~System.Byte">
            <summary>
            Convert to byte operator.
            </summary>
            <param name="type">the type to convert</param>
            <returns>The underlying value.</returns>
        </member>
        <member name="M:Jcd.Math.Intervals.IntervalLimitType.ToString">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Math.NamespaceDoc">
            <summary>
            Provides some rudimentary (and generic) math types and algorithms not 
            found in .NET by default.
            </summary>
        </member>
        <member name="T:Jcd.Math.Numbers.Epsilon">
            <summary>
            A DDD inspired enumeration for epsilon (ε). 
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.Epsilon.Negative">
            <summary>
            Infinitesimally less than zero.
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.Epsilon.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.Epsilon.Positive">
            <summary>
            Infinitesimally greater than zero.
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.Epsilon._value">
            <summary>
            The identifier for this <c>Epsilon</c> instance.
            </summary>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.#ctor(System.SByte)">
            <summary>
            Constructs an <c>Epsilon</c> instance from the numeric id.
            </summary>
            <param name="value">The numeric id of the infinitesimal component.</param>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.Equals(Jcd.Math.Numbers.Epsilon)">
            <summary>
            Compares this instance to another for equivalence.
            </summary>
            <param name="other">the other instance to compare against.</param>
            <returns>True if equivalent.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.op_Equality(Jcd.Math.Numbers.Epsilon,Jcd.Math.Numbers.Epsilon)">
            <summary>
            The equals operator. 
            </summary>
            <param name="left">the left hand operand</param>
            <param name="right">the right hand operand</param>
            <returns>true if equivalent</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.op_Inequality(Jcd.Math.Numbers.Epsilon,Jcd.Math.Numbers.Epsilon)">
            <summary>
            The not equals operator.
            </summary>
            <param name="left">the left hand operand</param>
            <param name="right">the right hand operand</param>
            <returns>true if not equivalent</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.CompareTo(Jcd.Math.Numbers.Epsilon)">
            <summary>
            Performs a relational (greater, less, equal) comparison between this instance
            and another instance.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.CompareTo(System.Object)">
            <summary>
            Performs a relational (greater, less, equal) comparison between this instance
            and an arbitrary object.
            </summary>
            <param name="obj">the other thing to compare it to.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">bad type for comparison.</exception>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.op_LessThan(Jcd.Math.Numbers.Epsilon,Jcd.Math.Numbers.Epsilon)">
            <summary>
            The less than operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is less than right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.op_GreaterThan(Jcd.Math.Numbers.Epsilon,Jcd.Math.Numbers.Epsilon)">
            <summary>
            The greater than operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is greater than right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.op_LessThanOrEqual(Jcd.Math.Numbers.Epsilon,Jcd.Math.Numbers.Epsilon)">
            <summary>
            The less than or equals operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is less than or equal to right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.op_GreaterThanOrEqual(Jcd.Math.Numbers.Epsilon,Jcd.Math.Numbers.Epsilon)">
            <summary>
            The greater than or equals operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is greater than or equal to right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Epsilon.ToString">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Math.Numbers.FiniteNumber`1">
            <summary>
            The representation of a finite number with a specified storage type.
            </summary>
            <typeparam name="TStorage">The data type to use to represent the finite number.</typeparam>
        </member>
        <member name="P:Jcd.Math.Numbers.FiniteNumber`1.Value">
            <summary>
            The underlying value for this FiniteNumber.
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.FiniteNumber`1.Zero">
            <summary>
            The value of Zero as a FiniteNumber&lt;TStorage&gt;
            </summary>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.#ctor(`0)">
            <summary>
            Construct a FiniteNumber from a specific value.
            </summary>
            <param name="value">The value to construct the number from.</param>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.CompareTo(Jcd.Math.Numbers.Infinity)">
            <summary>
            Compares this number to an infinity.
            A finite number is always larger than negative infinity.
            Also it's always smaller than positive infinity.
            </summary>
            <param name="other">The infinity.</param>
            <returns>-1 for Infinity.Positive; 1 for Infinity.Negative</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.CompareTo(Jcd.Math.Numbers.FiniteNumber{`0})">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.CompareTo(`0)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.CompareTo``1(Jcd.Math.Numbers.FiniteNumber{``0})">
            <summary>
            Compare to another FiniteNumber with a different base storage type.
            </summary>
            <param name="other">The other value.</param>
            <typeparam name="TOther">The other storage type.</typeparam>
            <returns>0 if equivalent, -1 if less than, 1 if greater.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.CompareTo``1(``0)">
            <summary>
            Compare the value to another struct with a different base storage type.
            </summary>
            <param name="other">The other value.</param>
            <typeparam name="TValue">The value storage type.</typeparam>
            <returns>0 if equivalent, -1 if less than, 1 if greater.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.Equals``1(Jcd.Math.Numbers.FiniteNumber{``0})">
            <summary>
            Compare to another FiniteNumber with a different base storage type.
            </summary>
            <param name="other">The other value.</param>
            <typeparam name="TOther">The other storage type.</typeparam>
            <returns>0 if equivalent, -1 if less than, 1 if greater.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.Equals``1(``0)">
            <summary>
            Compare this FiniteNumber to an arbitrary struct.
            This may incur a boxing operation if the struct isn't one
            it knows how to handle.
            </summary>
            <param name="other">The value to compare against.</param>
            <typeparam name="TValue">The data type of the value.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.Equals(`0)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.Equals(Jcd.Math.Numbers.FiniteNumber{`0})">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.Equals(Jcd.Math.Numbers.Infinity)">
            <summary>
            We know that finite numbers are never equal to infinite
            numbers by definition.
            </summary>
            <param name="other">the infinite number</param>
            <returns>false. This is always false.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.FiniteNumber`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Math.Numbers.Infinity">
            <summary>
            The default representation of any infinite value,
            positive or negative, regardless (this one uses a
            double implementation, for now. We'll see how
            performant it is.)
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.Infinity.Positive">
            <summary>
            The default instance of Positive Infinity.
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.Infinity.Negative">
            <summary>
            The default instance of Negative Infinity.
            </summary>
        </member>
        <member name="P:Jcd.Math.Numbers.Infinity.IsNegative">
            <summary>
            Indicates if this is Negative Infinity. 
            </summary>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.#ctor(System.Boolean)">
            <summary>
            Constructs a new instance of Infinity.
            </summary>
            <param name="isNegative">
            A flag indicating if this instance is negative
            infinity (true) or positive infinity (false)
            </param>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.CompareTo(Jcd.Math.Numbers.Infinity)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.CompareTo``1(``0)">
            <summary>
            Compares the infinity instance vs any other value/class.
            </summary>
            <param name="other"></param>
            <typeparam name="T"></typeparam>
            <returns>-1 if less than other; 1 if greater than other; o if equal.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.op_LessThan(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.Infinity)">
            <summary>
            Determines if an infinity is less than another infinity. 
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand</param>
            <returns>True if left less than right.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.op_GreaterThan(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.Infinity)">
            <summary>
            Determines if an infinity is greater than another infinity. 
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand</param>
            <returns>True if left greater than right.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.op_LessThanOrEqual(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.Infinity)">
            <summary>
            Determines if an infinity is less than or equal to another infinity. 
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand</param>
            <returns>True if left less than or equal to right.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.op_GreaterThanOrEqual(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.Infinity)">
            <summary>
            Determines if an infinity is greater than another infinity. 
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand</param>
            <returns>True if left greater than or equal to right.</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.Equals(Jcd.Math.Numbers.Infinity)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.op_Equality(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.Infinity)">
            <summary>
            Compares an two Infinity instances for equivalence.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Jcd.Math.Numbers.Infinity.op_Inequality(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.Infinity)">
            <summary>
            Compares an two Infinity instances for non-equivalence.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Jcd.Math.Numbers.NativeValueComparisons.Compare(System.Boolean,System.Byte)">
            <summary>
            Upcast bool to byte 0 if false 1 if true, then compare.
            </summary>
            <param name="x">left hand operand</param>
            <param name="y">right hand operand</param>
            <returns>-1 if x less than y; 1 if x greater than y; 0 if equal</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.NativeValueComparisons.Compare(System.Boolean,System.UInt16)">
            <summary>
            upcast bool to (byte)1/0 then compare.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:Jcd.Math.Numbers.qNaN">
            <summary>
            A storage agnostic non-signaling NaN implementation.
            </summary>
        </member>
        <member name="F:Jcd.Math.Numbers.qNaN.NaN">
            <summary>
            The singular instance of qNaN.
            Not sure HOW I'll use this just yet...
            I'll likely just implement operators for it against
            other integral data types. Most, will compare to false.
            </summary>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_LessThan(Jcd.Math.Numbers.qNaN,Jcd.Math.Numbers.qNaN)">
            <summary>
            The less than operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is less than right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_GreaterThan(Jcd.Math.Numbers.qNaN,Jcd.Math.Numbers.qNaN)">
            <summary>
            The greater than operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is greater than right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_LessThanOrEqual(Jcd.Math.Numbers.qNaN,Jcd.Math.Numbers.qNaN)">
            <summary>
            The less than or equals operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is less than or equal to right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_GreaterThanOrEqual(Jcd.Math.Numbers.qNaN,Jcd.Math.Numbers.qNaN)">
            <summary>
            The greater than or equals operator.
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>True if left is greater than or equal to right</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_Equality(Jcd.Math.Numbers.qNaN,Jcd.Math.Numbers.qNaN)">
            <summary>
            The equals operator. 
            </summary>
            <param name="left">the left hand operand</param>
            <param name="right">the right hand operand</param>
            <returns>true if equivalent</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_Inequality(Jcd.Math.Numbers.qNaN,Jcd.Math.Numbers.qNaN)">
            <summary>
            The not equals operator.
            </summary>
            <param name="left">the left hand operand</param>
            <param name="right">the right hand operand</param>
            <returns>true if not equivalent</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_Equality(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.qNaN)">
            <summary>
            The equals operator. 
            </summary>
            <param name="left">the left hand operand</param>
            <param name="right">the right hand operand</param>
            <returns>true if equivalent</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.op_Inequality(Jcd.Math.Numbers.Infinity,Jcd.Math.Numbers.qNaN)">
            <summary>
            The not equals operator.
            </summary>
            <param name="left">the left hand operand</param>
            <param name="right">the right hand operand</param>
            <returns>true if not equivalent</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.Equals(Jcd.Math.Numbers.qNaN)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.Equals``1(``0)">
            <summary>
            qNaN is always not equal to any value.
            </summary>
            <param name="other">The value to compare against.</param>
            <typeparam name="T">The type of the value being compared.</typeparam>
            <returns>false</returns>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Math.Numbers.qNaN.Comparer`1">
            <summary>
            The qNaN comparer implementation.
            </summary>
            <typeparam name="T">The other data being compared.</typeparam>
        </member>
        <member name="F:Jcd.Math.Numbers.qNaN.Comparer`1.Default">
            <summary>
            The default instance of the comparer.
            </summary>
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.Comparer`1.Compare(Jcd.Math.Numbers.qNaN,`0)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.Comparer`1.Compare(`0,Jcd.Math.Numbers.qNaN)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.Comparer`1.Equals(Jcd.Math.Numbers.qNaN,`0)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Math.Numbers.qNaN.Comparer`1.Equals(`0,Jcd.Math.Numbers.qNaN)">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Math.TypeExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:Jcd.Math.TypeExtensions.IsUserDefinedStructOrEnum(System.Type)">
            <summary>
            Determines if a type is a user defined struct
            or user defined enum.
            </summary>
            <param name="type">the type to inspect</param>
            <returns>true if the type is a used defined struct or enum.</returns>
        </member>
        <member name="M:Jcd.Math.TypeExtensions.IsPrimitiveStructOrEnum(System.Type)">
            <summary>
            Determines if a type is a a primitive struct or primitive (built-in) enum
            </summary>
            <param name="type">the type to inspect.</param>
            <returns>True if the type is a primitive struct or enum.</returns>
        </member>
    </members>
</doc>
